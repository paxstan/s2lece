import copy
import os
import numpy as np
from utils.transform_tools import persp_apply
from utils.data_conversion import project_point_cloud
from scipy.spatial.transform import Rotation as R
from scipy.signal import correlate2d
from PIL import Image


class Dataset(object):
    """ Base class for a dataset. To be overloaded.
    """
    root = ''
    img_dir = ''
    nimg = 0

    def __len__(self):
        return self.nimg

    def __repr__(self):
        res = 'Dataset: %s\n' % self.__class__.__name__
        res += '  %d images' % self.nimg
        res += '\n  root: %s...\n' % self.root
        return res


class LidarBase(Dataset):
    def __init__(self):
        Dataset.__init__(self)

    def get_image(self, img_idx):
        folder_path = os.path.join(self.root, img_idx)
        rang = self.load_np_file(folder_path + '/range.npy')
        img = Image.fromarray(rang)
        return img

    def get_valid_range_mask(self, idx):
        folder_path = os.path.join(self.root, idx)
        mask = np.load(folder_path + '/valid_mask.npy')
        return mask

    def get_xyz(self, idx):
        folder_path = os.path.join(self.root, idx)
        xyz = np.load(folder_path + '/xyz.npy')
        return xyz

    @staticmethod
    def load_np_file(path):
        return np.load(path)


class RealPairDataset(LidarBase):
    def __init__(self, root):
        LidarBase.__init__(self)
        self.root = root
        self.gt_pose = np.load(f'{root}/ground_truth_pose.npy') if os.path.exists(f'{root}/ground_truth_pose.npy') \
            else None
        self.arr_corres = np.load(f'{root}/corres.npy', allow_pickle=True) if os.path.exists(
            f'{root}/corres.npy') else None
        self.npairs = self.arr_corres.shape[0]

    def __len__(self):
        self.npairs = self.arr_corres.shape[0]
        return self.npairs

    @staticmethod
    def get_homog_matrix(pose):
        """
        Transforms a pose to a homogeneous matrix
        :param pose: [x, y, z, qx, qy, qz, qw]
        :return: 4x4 homogeneous matrix
        """
        m = np.eye(4)
        rot = R.from_quat(pose[3:])
        for i in range(3):
            m[i, 3] = pose[i]
        m[0:3, 0:3] = rot.as_matrix()
        return m

    def get_pair(self, idx):
        """ returns (img1, img2, `metadata`)
        """
        source = str(self.arr_corres[idx][0])
        target = str(self.arr_corres[idx][1])
        corres_dir = self.arr_corres[idx][2]

        img1 = self.load_np_file(os.path.join(self.root, source, 'range.npy'))
        img2 = self.load_np_file(os.path.join(self.root, target, 'range.npy'))
        mask1 = np.load(os.path.join(self.root, source, 'valid_mask.npy'))
        mask2 = np.load(os.path.join(self.root, target, 'valid_mask.npy'))
        flow = self.load_np_file(os.path.join(self.root, "correspondence", corres_dir, 'flow.npy'))
        # mask_valid_in_2 = self.load_np_file(os.path.join(self.root,
        #                                                  "correspondence", corres_dir, 'mask_valid_2.npy'))

        idx1 = self.load_np_file(os.path.join(self.root, source, 'idx.npy'))
        idx2 = self.load_np_file(os.path.join(self.root, target, 'idx.npy'))

        xyz1 = self.load_np_file(os.path.join(self.root, source, 'xyz.npy'))
        xyz2 = self.load_np_file(os.path.join(self.root, target, 'xyz.npy'))

        img1 = img1 * mask1
        img1[img1 == -0.0] = 0.0

        img2 = img2 * mask2
        img2[img2 == -0.0] = 0.0


        # h1, w1 = img1.shape
        # h2, w2 = img2.shape
        #
        # img1 = img1.reshape(-1)
        # img2 = img2.reshape(-1)
        #
        # img1[np.invert(mask1)] = 0
        # img2[np.invert(mask2)] = 0

        # reshape masks of valid pixels to image sizes
        # mask1 = mask1.reshape(h1, w1)
        # mask2 = mask2.reshape(h2, w2)

        # redefine flow mask with invalid pixels in image1 and mask generated by finding flow
        mask = (mask1 * mask2).astype(bool)

        # set flow for invalid pixels to nan, which is ignored during training
        # flow[~mask, :] = 0

        # crop image
        # img2 = Image.fromarray(img2.reshape(h1, w1))
        # img1 = Image.fromarray(img1.reshape(h1, w1))
        # img1 = img1.reshape(h1, w1)
        # img2 = img2.reshape(h2, w2)
        # img1[img1 < 0] = 0
        # img2[img2 < 0] = 0
        # img1 = (img1 - np.min(img1)) / (np.max(img1) - np.min(img1))
        # img2 = (img2 - np.min(img2)) / (np.max(img2) - np.min(img2))

        meta = {'aflow': flow.transpose((2, 0, 1)), 'flow_mask': mask,
                'mask1': mask1.astype(bool), 'mask2': mask2.astype(bool),
                'idx1': idx1, 'idx2': idx2, 'xyz1': xyz1, 'xyz2': xyz2}
        return img1, img2, meta


class LidarData:
    def __init__(self, path):
        self.corres = np.load(f'{path}/corres.npy') if os.path.exists(f'{path}/corres.npy') else None
        self.idx_data = np.load(f'{path}/idx.npy') if os.path.exists(f'{path}/idx.npy') else None
        self.world_frame = np.load(f'{path}/world_frame.npy') if os.path.exists(f'{path}/world_frame.npy') else None
        self.range_data = np.load(f'{path}/range.npy') if os.path.exists(f'{path}/range.npy') else None
        self.xyz_data = np.load(f'{path}/xyz.npy') if os.path.exists(f'{path}/xyz.npy') else None
        self.valid_mask = np.load(f'{path}/valid_mask.npy') if os.path.exists(f'{path}/valid_mask.npy') else None


class SingleDataset(LidarBase):
    def __init__(self, root):
        LidarBase.__init__(self)
        self.root = root
        self.npairs = self.get_count()

    def get_count(self):
        abspath = os.path.abspath(self.root)
        listdir = os.listdir(abspath)
        return sum([os.path.isdir(os.path.join(abspath + "/" + dr)) for dr in listdir if dr != "correspondence"])

    def __len__(self):
        return self.npairs

    def get_item(self, idx):
        img = self.load_np_file(os.path.join(self.root, str(idx), 'range.npy'))
        mask = self.load_np_file(os.path.join(self.root, str(idx), 'valid_mask.npy'))
        img = img * mask
        img[img == -0.0] = 0.0

        return img, mask



