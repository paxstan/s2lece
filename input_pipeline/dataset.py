import copy
import os
import numpy as np
from utils.transform_tools import persp_apply
from utils.data_conversion import project_point_cloud
from scipy.spatial.transform import Rotation as R
from scipy.signal import correlate2d
from PIL import Image


class Dataset(object):
    """ Base class for a dataset. To be overloaded.
    """
    root = ''
    img_dir = ''
    nimg = 0

    def __len__(self):
        return self.nimg

    def __repr__(self):
        res = 'Dataset: %s\n' % self.__class__.__name__
        res += '  %d images' % self.nimg
        res += '\n  root: %s...\n' % self.root
        return res


class LidarBase(Dataset):
    def __init__(self, crop=True):
        Dataset.__init__(self)
        self.crop = crop
        self.crop_size = 250
        self.H = 128

    def get_image(self, img_idx):
        folder_path = os.path.join(self.root, img_idx)
        rang = self.load_np_file(folder_path + '/range.npy')
        img = Image.fromarray(rang)
        return img

    def get_valid_range_mask(self, idx):
        folder_path = os.path.join(self.root, idx)
        mask = np.load(folder_path + '/valid_mask.npy')
        return mask

    def get_xyz(self, idx):
        folder_path = os.path.join(self.root, idx)
        xyz = np.load(folder_path + '/xyz.npy')
        return xyz

    @staticmethod
    def load_np_file(path):
        return np.load(path)


class RealPairDataset(LidarBase):
    def __init__(self, root, crop=False, reproject=True):
        LidarBase.__init__(self, crop)
        self.root = root
        self.gt_pose = np.load(f'{root}/ground_truth_pose.npy') if os.path.exists(f'{root}/ground_truth_pose.npy') \
            else None
        self.arr_corres = np.load(f'{root}/corres.npy', allow_pickle=True) if os.path.exists(
            f'{root}/corres.npy') else None
        self.npairs = self.arr_corres.shape[0]
        self.reproject = reproject

    def __len__(self):
        self.npairs = self.arr_corres.shape[0]
        return self.npairs

    @staticmethod
    def get_homog_matrix(pose):
        """
        Transforms a pose to a homogeneous matrix
        :param pose: [x, y, z, qx, qy, qz, qw]
        :return: 4x4 homogeneous matrix
        """
        m = np.eye(4)
        rot = R.from_quat(pose[3:])
        for i in range(3):
            m[i, 3] = pose[i]
        m[0:3, 0:3] = rot.as_matrix()
        return m

    def get_pair(self, idx):
        """ returns (img1, img2, `metadata`)
        """
        source = str(self.arr_corres[idx][0])
        target = str(self.arr_corres[idx][1])
        corres_dir = self.arr_corres[idx][2]

        img1 = self.load_np_file(os.path.join(self.root, source, 'range.npy'))
        img2 = self.load_np_file(os.path.join(self.root, target, 'range.npy'))
        mask1 = np.load(os.path.join(self.root, source, 'valid_mask.npy')).reshape(-1)
        mask2 = np.load(os.path.join(self.root, target, 'valid_mask.npy')).reshape(-1)
        flow = self.load_np_file(os.path.join(self.root, "correspondence", corres_dir, 'flow.npy'))
        mask_valid_in_2 = self.load_np_file(os.path.join(self.root, "correspondence", corres_dir, 'mask_valid_2.npy'))

        h1, w1 = img1.shape
        # h2, w2 = img2.shape

        img1 = img1.reshape(-1)
        img2 = img2.reshape(-1)

        img1[np.invert(mask1)] = 0
        img2[np.invert(mask2)] = 0

        # reshape masks of valid pixels to image sizes
        mask1 = mask1.reshape(h1, w1)
        # mask2 = mask2.reshape(h2, w2)

        # get flow according to pair index and reprojected mask2
        # flow, mask_valid_in_2 = get_pixel_match(self.root, mask2, source, target, corres, (h1, w1))

        # redefine flow mask with invalid pixels in image1 and maks generated by finding flow
        mask = (mask1 * mask_valid_in_2).astype(bool)

        # set flow for invalid pixels to nan, which is ignored during training
        flow[~mask, :] = 0

        # crop image
        # img2 = Image.fromarray(img2.reshape(h1, w1))
        # img1 = Image.fromarray(img1.reshape(h1, w1))
        img1 = img1.reshape(h1, w1)
        img2 = img2.reshape(h1, w1)

        meta = {'aflow': flow.transpose((2, 0, 1)), 'mask': mask}
        return img1, img2, meta


class SyntheticPairDataset(LidarBase):
    """ A synthetic generator of image pairs.
            Given a normal image dataset, it constructs pairs using random homographies & noise.
        """

    def __init__(self, root, scale=None, distort=None, crop=False):
        LidarBase.__init__(self, crop)
        self.root = root
        self.distort = distort
        self.scale = scale

    @staticmethod
    def make_pair(img):
        return img, img

    def get_pair(self, org_img, output=('aflow')):
        """ Procedure:
        This function applies a series of random transformations to one original image
        to form a synthetic image pairs with perfect ground-truth.
        """
        if isinstance(output, str):
            output = output.split()

        original_img = org_img
        scaled_image = self.scale(original_img)
        scaled_image, scaled_image2 = self.make_pair(scaled_image['img'])
        # scaled_image = original_img
        rand_tilt = self.distort[0](inp=dict(img=scaled_image2, persp=(1, 0, 0, 0, 1, 0, 0, 0)))
        rand_noise = self.distort[1](inp=rand_tilt)
        scaled_and_distorted_image = self.distort[2](inp=rand_noise)
        # scaled_and_distorted_image = self.distort(
        #     dict(img=scaled_image2, persp=(1, 0, 0, 0, 1, 0, 0, 0)))
        W, H = scaled_image.size
        trf = scaled_and_distorted_image['persp']

        meta = dict()
        meta['mask'] = org_img['mask']
        if 'aflow' in output or 'flow' in output:
            # compute optical flow
            xy = np.mgrid[0:H, 0:W][::-1].reshape(2, H * W).T
            aflow = np.float32(persp_apply(trf, xy).reshape(H, W, 2))
            meta['flow'] = aflow - xy.reshape(H, W, 2)
            meta['aflow'] = aflow

        if 'homography' in output:
            meta['homography'] = np.float32(trf + (1,)).reshape(3, 3)

        return scaled_image, scaled_and_distorted_image['img'], meta


class LidarData:
    def __init__(self, path):
        self.corres = np.load(f'{path}/corres.npy') if os.path.exists(f'{path}/corres.npy') else None
        self.idx_data = np.load(f'{path}/idx.npy') if os.path.exists(f'{path}/idx.npy') else None
        self.world_frame = np.load(f'{path}/world_frame.npy') if os.path.exists(f'{path}/world_frame.npy') else None
        self.range_data = np.load(f'{path}/range.npy') if os.path.exists(f'{path}/range.npy') else None
        self.xyz_data = np.load(f'{path}/xyz.npy') if os.path.exists(f'{path}/xyz.npy') else None
        self.valid_mask = np.load(f'{path}/valid_mask.npy') if os.path.exists(f'{path}/valid_mask.npy') else None


class SingleDataset(LidarBase):
    def __init__(self, root, scale=None, distort=None, crop=False):
        LidarBase.__init__(self, crop)
        self.root = root
        self.scale = scale
        self.distort = distort
        self.npairs = self.get_count()

    def get_count(self):
        abspath = os.path.abspath(self.root)
        listdir = os.listdir(abspath)
        return sum([os.path.isdir(os.path.join(abspath + "/" + dr)) for dr in listdir if dr != "correspondence"])

    def __len__(self):
        return self.npairs

    def get_item(self, idx):
        img = self.load_np_file(os.path.join(self.root, str(idx), 'range.npy'))
        mask = self.load_np_file(os.path.join(self.root, str(idx), 'valid_mask.npy')).reshape(-1)

        h1, w1 = img.shape
        img = img.reshape(-1)
        img[np.invert(mask)] = 0
        img = img.reshape(h1, w1)

        return img


def get_pixel_match(mask2, source, target, corres, shape1):
    h1, w1 = shape1
    h2, w2 = mask2.shape
    xyz1 = np.load(os.path.join(source, 'xyz.npy'))
    xyz2 = np.load(os.path.join(target, 'xyz.npy'))

    corres1 = np.where(corres != -1)[0]
    corres2 = corres[corres1]

    proj_x1, proj_y1, depth1 = project_point_cloud(xyz1[corres1])
    proj_x2, proj_y2, depth2 = project_point_cloud(xyz2[corres2])

    range1 = np.full((h1, w1), 9999999, dtype=np.float32)
    range2 = np.full((h2, w2), -9999999, dtype=np.float32)

    range1[proj_y1, proj_x1] = depth1
    range2[proj_y2, proj_x2] = depth2

    cor = correlate2d(range1, range2)
    shift_y = proj_y2 - proj_y1
    shift_x = proj_x2 - proj_x1
    flow = np.zeros((h2, w2, 2))
    flow[proj_y2, proj_x2, 0] = shift_y
    flow[proj_y2, proj_x2, 1] = shift_x

    # get mask of which pixels in image1 are valid in image2 (out of bounds and invalid defined by mask2)
    x_img = flow[:, :, 0].reshape(-1).astype(int)
    y_img = flow[:, :, 1].reshape(-1).astype(int)
    mask_valid_in_2 = np.zeros(h1 * w1, dtype=bool)
    mask_in_bound = (y_img >= 0) * (y_img < h2) * (x_img >= 0) * (x_img < w2)
    mask_valid_in_2[mask_in_bound] = mask2[y_img[mask_in_bound], x_img[mask_in_bound]]

    # get ranges of valid image2 points
    r2 = range2.reshape(-1)[mask_valid_in_2]
    # get corresponding transformed ranges of image1
    r1_t = range1.reshape(-1)[mask_valid_in_2]

    # check if points in image1 are occluded in 2
    d = (r2 - r1_t) / r1_t
    # 20% threshold when close to each other
    not_occluded = d > -0.2
    # define occlusion mask
    occlusion_mask = np.ones((h1 * w1), dtype=bool)
    occlusion_mask[mask_valid_in_2] = not_occluded

    # set mask_valid_in_2 false when occluded
    mask_valid_in_2 = np.logical_and(mask_valid_in_2, occlusion_mask)
    mask_valid_in_2 = mask_valid_in_2.reshape(h1, w1)

    # mask flow according to occluded points
    flow[:, :, 0][np.invert(mask_valid_in_2)] = 0
    flow[:, :, 1][np.invert(mask_valid_in_2)] = 0

    return flow, mask_valid_in_2



